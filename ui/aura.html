<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Aura</title>
    <style>
      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: transparent;
      }

      canvas {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }

      #hud {
        position: fixed;
        left: 50%;
        bottom: 46px;
        transform: translateX(-50%);
        width: min(920px, calc(100vw - 40px));
        border-radius: 16px;
        border: 1px solid rgba(148, 163, 184, 0.42);
        background: linear-gradient(
          140deg,
          rgba(255, 255, 255, 0.8),
          rgba(250, 252, 255, 0.72)
        );
        box-shadow:
          0 0 0 1px rgba(255, 255, 255, 0.45) inset,
          0 16px 38px rgba(15, 23, 42, 0.16);
        backdrop-filter: blur(8px);
        color: #0f172a;
        pointer-events: none;
        opacity: 0;
        transition: opacity 180ms ease;
        padding: 10px 14px;
        font-family: 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
      }

      #hud.visible {
        opacity: 1;
      }

      .hud-label {
        font-size: 11px;
        color: #64748b;
        letter-spacing: 0.02em;
      }

      #thought {
        margin-top: 2px;
        font-size: 14px;
        line-height: 1.35;
        color: #111827;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .hud-row {
        margin-top: 8px;
      }

      #action {
        margin-top: 2px;
      }

      #actionPrimary {
        font-size: 14px;
        line-height: 1.35;
        color: #0f172a;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      #actionSecondary {
        margin-top: 2px;
        font-family: 'Cascadia Code', 'Consolas', monospace;
        font-size: 12px;
        line-height: 1.3;
        color: #334155;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
    </style>
  </head>
  <body>
    <canvas id="aura"></canvas>
    <section id="hud" aria-live="polite">
      <div class="hud-label">AI 思考</div>
      <div id="thought">等待任务开始...</div>
      <div class="hud-row">
        <div class="hud-label">当前操作</div>
        <div id="action">
          <div id="actionPrimary">待命</div>
          <div id="actionSecondary"></div>
        </div>
      </div>
    </section>

    <script>
      const canvas = document.getElementById('aura');
      const ctx = canvas.getContext('2d', { alpha: true });
      const hud = document.getElementById('hud');
      const thoughtEl = document.getElementById('thought');
      const actionPrimaryEl = document.getElementById('actionPrimary');
      const actionSecondaryEl = document.getElementById('actionSecondary');
      const bridge = window.autogui;

      const maskCanvas = document.createElement('canvas');
      const maskCtx = maskCanvas.getContext('2d', { alpha: true });
      const transitionCanvas = document.createElement('canvas');
      const transitionCtx = transitionCanvas.getContext('2d', { alpha: true });

      let cssWidth = 0;
      let cssHeight = 0;
      let dpr = 1;
      let fadeThickness = 30;
      let transitionW = 0;
      let transitionH = 0;
      let transitionMap = new Float32Array(1);
      let transitionImage = null;
      let auraState = 'hidden'; // hidden | entering | visible | exiting
      let transitionStartMs = 0;
      const transitionDurationMs = 460;

      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }

      function buildFadeMask() {
        maskCanvas.width = Math.round(cssWidth);
        maskCanvas.height = Math.round(cssHeight);
        maskCtx.clearRect(0, 0, cssWidth, cssHeight);

        const image = maskCtx.createImageData(Math.round(cssWidth), Math.round(cssHeight));
        const data = image.data;
        const w = Math.round(cssWidth);
        const h = Math.round(cssHeight);
        const innerInset = fadeThickness;
        const innerRadius = Math.max(1, Math.round(fadeThickness * 0.058));
        const cx = w / 2;
        const cy = h / 2;
        const halfW = Math.max(1, w / 2 - innerInset);
        const halfH = Math.max(1, h / 2 - innerInset);
        const roundLimit = Math.max(0, Math.min(halfW, halfH) - 1);
        const r = Math.min(innerRadius, roundLimit);

        function sdfRoundedRect(px, py) {
          const dx = Math.abs(px - cx) - (halfW - r);
          const dy = Math.abs(py - cy) - (halfH - r);
          const ox = Math.max(dx, 0);
          const oy = Math.max(dy, 0);
          const outside = Math.hypot(ox, oy);
          const inside = Math.min(Math.max(dx, dy), 0);
          return outside + inside - r;
        }

        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const dEdge = Math.min(x, y, w - 1 - x, h - 1 - y);
            // Keep outer contour rectangular; inner contour rounded.
            // Alpha grows from inner rounded boundary -> outer screen edge.
            const sdf = sdfRoundedRect(x, y);
            const outsideDist = Math.max(0, sdf);
            const innerFade = Math.pow(clamp(outsideDist / fadeThickness, 0, 1), 1.55);
            // Force a straight, pixel-tight outer boundary (no rounded outer corner).
            const outerPin = clamp(1 - dEdge / 1.6, 0, 1);
            const alpha = Math.max(innerFade, outerPin);
            const idx = (y * w + x) * 4;
            data[idx] = 255;
            data[idx + 1] = 255;
            data[idx + 2] = 255;
            data[idx + 3] = Math.round(alpha * 255);
          }
        }

        maskCtx.putImageData(image, 0, 0);
      }

      function buildTransitionMap() {
        transitionW = Math.max(1, Math.round(cssWidth));
        transitionH = Math.max(1, Math.round(cssHeight));
        transitionCanvas.width = transitionW;
        transitionCanvas.height = transitionH;
        transitionMap = new Float32Array(transitionW * transitionH);
        transitionImage = transitionCtx.createImageData(transitionW, transitionH);

        const w = transitionW;
        const h = transitionH;
        const perimeter = 2 * (w + h);
        const halfPerimeter = perimeter * 0.5;
        // Start from bottom-center, then spread to both directions along the border.
        const startS = w + h + w * 0.5;

        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const dTop = y;
            const dRight = w - 1 - x;
            const dBottom = h - 1 - y;
            const dLeft = x;
            const minD = Math.min(dTop, dRight, dBottom, dLeft);

            let s = 0;
            if (minD === dBottom) {
              s = w + h + (w - x);
            } else if (minD === dRight) {
              s = w + y;
            } else if (minD === dTop) {
              s = x;
            } else {
              s = 2 * w + h + (h - y);
            }

            const delta = Math.abs(s - startS);
            const pathDist = Math.min(delta, perimeter - delta);
            const normalized = clamp(pathDist / halfPerimeter, 0, 1);
            transitionMap[y * w + x] = normalized;
          }
        }
      }

      function resize() {
        dpr = Math.max(1, window.devicePixelRatio || 1);
        cssWidth = window.innerWidth;
        cssHeight = window.innerHeight;

        canvas.width = Math.round(cssWidth * dpr);
        canvas.height = Math.round(cssHeight * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        const shortest = Math.min(cssWidth, cssHeight);
        // Keep transition narrow to avoid heavy visual occupation.
        fadeThickness = Math.max(18, Math.min(36, shortest * 0.032));
        buildFadeMask();
        buildTransitionMap();
      }

      function makeConicGradient(phase) {
        const g = ctx.createConicGradient(phase, cssWidth / 2, cssHeight / 2);
        g.addColorStop(0.0, '#39e8ff');
        g.addColorStop(0.18, '#71ffad');
        g.addColorStop(0.36, '#ffeb7e');
        g.addColorStop(0.54, '#ff8ea0');
        g.addColorStop(0.72, '#73a9ff');
        g.addColorStop(0.88, '#44e2ff');
        g.addColorStop(1.0, '#39e8ff');
        return g;
      }

      function applyPerimeterRevealMask(progress) {
        if (!transitionImage || transitionW <= 0 || transitionH <= 0) return;
        const p = clamp(progress, 0, 1);
        const band = 0.038;
        const data = transitionImage.data;
        const total = transitionMap.length;

        for (let i = 0; i < total; i++) {
          const n = transitionMap[i];
          const t = clamp((p - n + band) / (band * 2), 0, 1);
          const eased = t * t * (3 - 2 * t);
          const a = Math.round(eased * 255);
          const idx = i * 4;
          data[idx] = 255;
          data[idx + 1] = 255;
          data[idx + 2] = 255;
          data[idx + 3] = a;
        }

        transitionCtx.putImageData(transitionImage, 0, 0);
        ctx.globalCompositeOperation = 'destination-in';
        ctx.drawImage(transitionCanvas, 0, 0, cssWidth, cssHeight);
      }

      function drawFrame(ts) {
        const t = ts * 0.001;
        const phase = t * 0.72;
        const sharedGradient = makeConicGradient(phase);

        ctx.clearRect(0, 0, cssWidth, cssHeight);
        if (auraState === 'hidden') {
          requestAnimationFrame(drawFrame);
          return;
        }

        // One continuous color field for the whole perimeter.
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = sharedGradient;
        ctx.fillRect(0, 0, cssWidth, cssHeight);

        // Edge-to-inner transparency gradient mask.
        ctx.globalCompositeOperation = 'destination-in';
        ctx.drawImage(maskCanvas, 0, 0, cssWidth, cssHeight);

        if (auraState === 'entering' || auraState === 'exiting') {
          const elapsed = Math.max(0, ts - transitionStartMs);
          const raw = Math.min(1, elapsed / transitionDurationMs);
          const eased = 1 - Math.pow(1 - raw, 2.15);

          if (auraState === 'entering') {
            // Bottom-center -> bottom sides -> side edges up -> top edges -> top center.
            applyPerimeterRevealMask(eased);
            if (raw >= 1) {
              auraState = 'visible';
            }
          } else {
            // Reverse order of reveal.
            applyPerimeterRevealMask(1 - eased);
            if (raw >= 1) {
              auraState = 'hidden';
            }
          }
        }

        requestAnimationFrame(drawFrame);
      }

      function startReveal() {
        auraState = 'entering';
        transitionStartMs = performance.now();
      }

      function startHide() {
        if (auraState === 'hidden') return;
        auraState = 'exiting';
        transitionStartMs = performance.now();
      }

      function clipText(text, max = 220) {
        const clean = String(text || '').replace(/\s+/g, ' ').trim();
        if (!clean) return '';
        return clean.length > max ? `${clean.slice(0, max)}...` : clean;
      }

      function setThought(text) {
        const next = clipText(text, 240);
        if (next) thoughtEl.textContent = next;
      }

      function setAction(primary, secondary = '') {
        const p = clipText(primary, 220);
        if (p) actionPrimaryEl.textContent = p;
        actionSecondaryEl.textContent = clipText(secondary, 220);
      }

      function extractFirstJsonObject(text) {
        const source = String(text || '');
        const start = source.indexOf('{');
        if (start < 0) return null;

        let depth = 0;
        let inString = false;
        let escaped = false;
        for (let i = start; i < source.length; i++) {
          const ch = source[i];
          if (inString) {
            if (escaped) {
              escaped = false;
              continue;
            }
            if (ch === '\\') {
              escaped = true;
              continue;
            }
            if (ch === '"') inString = false;
            continue;
          }
          if (ch === '"') {
            inString = true;
            continue;
          }
          if (ch === '{') depth++;
          if (ch === '}') {
            depth--;
            if (depth === 0) return source.slice(start, i + 1);
          }
        }
        return null;
      }

      function formatActionPretty(rawText) {
        const jsonChunk = extractFirstJsonObject(rawText);
        if (!jsonChunk) return null;

        let action;
        try {
          action = JSON.parse(jsonChunk);
        } catch {
          return null;
        }

        if (!action || typeof action !== 'object') return null;
        const type = String(action.action || 'unknown');
        const x = action.x;
        const y = action.y;
        const map = {
          click: '单击',
          double_click: '双击',
          right_click: '右键',
          long_press: '长按',
          type: '输入',
          enter: '回车',
          press: '组合键',
          scroll: '滚动',
          drag: '拖拽',
          move: '移动鼠标',
          wait: '等待',
          task_complete: '完成任务',
        };
        const label = map[type] || type;

        if (type === 'click' || type === 'double_click' || type === 'right_click' || type === 'move') {
          return { primary: `${label} (${x}, ${y})` };
        }
        if (type === 'long_press') {
          return {
            primary: `${label} (${x}, ${y})`,
            secondary: `按住 ${(Number(action.hold_seconds) || 1).toFixed(1)}s`,
          };
        }
        if (type === 'type') {
          return { primary: `${label}: ${String(action.text || '').slice(0, 48)}` };
        }
        if (type === 'press') {
          const keys = Array.isArray(action.keys) ? action.keys.join(' + ') : '';
          return { primary: `${label}: ${keys}` };
        }
        if (type === 'scroll') {
          return { primary: `${label}: ${Number(action.scroll_amount) || 0}` };
        }
        if (type === 'drag') {
          return {
            primary: `${label} (${action.x}, ${action.y}) -> (${action.end_x}, ${action.end_y})`,
          };
        }
        if (type === 'wait') {
          return { primary: `${label} ${Number(action.duration) || 0}ms` };
        }
        return { primary: label };
      }

      bridge.onStatus(({ status, detail }) => {
        if (status === 'running') {
          hud.classList.add('visible');
          setThought('正在执行新任务...');
          setAction('准备截图并分析');
          if (detail) setAction(detail);
          return;
        }

        if (status === 'error') {
          hud.classList.add('visible');
          setAction(`错误: ${detail || '未知错误'}`);
          return;
        }

        if (status === 'idle') {
          if (detail) setAction(detail);
          setTimeout(() => hud.classList.remove('visible'), 1200);
        }
      });

      bridge.onLog(({ message }) => {
        if (!message) return;
        if (message.includes('AI 思考:')) {
          setThought(message.replace(/^.*AI 思考:\s*/, ''));
          return;
        }
        if (message.includes('AI 操作:')) {
          const raw = message.replace(/^.*AI 操作:\s*/, '');
          const pretty = formatActionPretty(raw);
          if (pretty) {
            setAction(pretty.primary, pretty.secondary || '');
          } else {
            setAction(`执行动作`, raw.replace(/\s+/g, ' '));
          }
          return;
        }
        if (message.includes('Execute action:')) {
          setAction(message.replace(/^.*Execute action:\s*/, '执行: '));
        }
      });

      bridge.onAuraVisibility(({ visible }) => {
        if (visible) {
          startReveal();
        } else {
          startHide();
        }
      });

      window.addEventListener('resize', resize);
      resize();
      requestAnimationFrame(drawFrame);
    </script>
  </body>
</html>
